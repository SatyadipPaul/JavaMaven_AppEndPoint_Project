package com.example.dynamicgrid;

import com.vaadin.flow.component.grid.Grid;
import com.vaadin.flow.component.grid.GridVariant;
import com.vaadin.flow.data.provider.DataProvider;
import com.vaadin.flow.data.provider.QuerySortOrder;
import com.vaadin.flow.data.provider.SortDirection;
import com.vaadin.flow.data.renderer.NumberRenderer;
import com.vaadin.flow.data.renderer.LocalDateRenderer;
import com.vaadin.flow.data.renderer.LocalDateTimeRenderer;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Service;

import java.math.BigDecimal;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.sql.Types;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.stream.Collectors;

@Service
public class DynamicQueryGridService {

    @Autowired
    private JdbcTemplate jdbcTemplate;
    
    // Record definitions for immutable data structures
    public record ColumnMetadata(
            String name,
            String label,
            int sqlType,
            boolean nullable,
            Class<?> javaType) {}
    
    /**
     * Creates a dynamic Grid based on an SQL query with lazy loading.
     * 
     * @param sqlQuery The SQL query to execute
     * @return A configured Vaadin Grid
     */
    public Grid<Map<String, Object>> createDynamicGrid(String sqlQuery) {
        // Step 1: Get column metadata from the query
        List<ColumnMetadata> columns = getColumnMetadata(sqlQuery);
        
        // Step 2: Create a grid with lazy loading data provider
        Grid<Map<String, Object>> grid = new Grid<>();
        grid.addThemeVariants(GridVariant.LUMO_ROW_STRIPES, GridVariant.LUMO_COLUMN_BORDERS);
        
        // Step 3: Add columns with appropriate renderers based on data types
        addColumnsToGrid(grid, columns);
        
        // Step 4: Configure lazy loading data provider
        configureLazyDataProvider(grid, sqlQuery, columns);
        
        return grid;
    }
    
    /**
     * Gets column metadata from the query by executing a query that fetches no rows.
     */
    private List<ColumnMetadata> getColumnMetadata(String sqlQuery) {
        List<ColumnMetadata> columns = new ArrayList<>();
        
        // For Oracle, use ROWNUM <= 0 to get metadata without rows
        String metadataQuery = wrapQueryForMetadata(sqlQuery);
            
        jdbcTemplate.query(metadataQuery, rs -> {
            ResultSetMetaData metaData = rs.getMetaData();
            int columnCount = metaData.getColumnCount();
            
            for (int i = 1; i <= columnCount; i++) {
                String name = metaData.getColumnName(i);
                String label = metaData.getColumnLabel(i);
                int sqlType = metaData.getColumnType(i);
                boolean nullable = metaData.isNullable(i) == ResultSetMetaData.columnNullable;
                Class<?> javaType = mapSqlTypeToJavaType(sqlType);
                
                columns.add(new ColumnMetadata(name, label, sqlType, nullable, javaType));
            }
        });
        
        return columns;
    }
    
    /**
     * Wraps a query to fetch metadata only without returning actual rows.
     * Oracle-specific implementation.
     */
    private String wrapQueryForMetadata(String query) {
        // For Oracle: use ROWNUM to limit to 0 rows
        return "SELECT * FROM (" + query + ") WHERE ROWNUM <= 0";
    }
    
    /**
     * Maps SQL type to Java type.
     */
    private Class<?> mapSqlTypeToJavaType(int sqlType) {
        return switch (sqlType) {
            case Types.CHAR, Types.VARCHAR, Types.LONGVARCHAR, Types.NCHAR, 
                 Types.NVARCHAR, Types.LONGNVARCHAR, Types.CLOB, Types.NCLOB -> String.class;
            case Types.NUMERIC, Types.DECIMAL -> BigDecimal.class;
            case Types.BIT, Types.BOOLEAN -> Boolean.class;
            case Types.TINYINT, Types.SMALLINT, Types.INTEGER -> Integer.class;
            case Types.BIGINT -> Long.class;
            case Types.REAL, Types.FLOAT, Types.DOUBLE -> Double.class;
            case Types.BINARY, Types.VARBINARY, Types.LONGVARBINARY, Types.BLOB -> byte[].class;
            case Types.DATE -> LocalDate.class;
            case Types.TIME, Types.TIMESTAMP -> LocalDateTime.class;
            default -> Object.class;
        };
    }
    
    /**
     * Adds columns to the grid with appropriate renderers based on data types.
     */
    private void addColumnsToGrid(Grid<Map<String, Object>> grid, List<ColumnMetadata> columns) {
        for (ColumnMetadata col : columns) {
            Grid.Column<Map<String, Object>> column;
            
            // Apply different renderers based on data type
            if (col.javaType() == LocalDate.class) {
                column = grid.addColumn(new LocalDateRenderer<>(
                    item -> (LocalDate) item.get(col.name()),
                    DateTimeFormatter.ofPattern("MM/dd/yyyy")  // Simple MM/dd/yyyy pattern
                ));
            } else if (col.javaType() == LocalDateTime.class) {
                column = grid.addColumn(new LocalDateTimeRenderer<>(
                    item -> (LocalDateTime) item.get(col.name()),
                    DateTimeFormatter.ofPattern("MM/dd/yyyy HH:mm:ss")  // Standard datetime pattern
                ));
            } else if (col.javaType() == BigDecimal.class || 
                       col.javaType() == Double.class || 
                       col.javaType() == Float.class) {
                column = grid.addColumn(new NumberRenderer<>(
                    item -> item.get(col.name()) instanceof Number n ? n.doubleValue() : 0.0,
                    "%.2f"
                ));
            } else if (col.javaType() == byte[].class) {
                // Special handling for binary data like BLOBs
                column = grid.addColumn(item -> {
                    byte[] data = (byte[]) item.get(col.name());
                    if (data == null) {
                        return "No data";
                    } else {
                        return formatByteSize(data.length);
                    }
                });
            } else {
                // Default renderer with null handling
                column = grid.addColumn(item -> {
                    Object value = item.get(col.name());
                    return value != null ? value.toString() : "";
                });
            }
            
            // Configure column properties
            column.setHeader(formatColumnHeader(col.label()))
                  .setKey(col.name())
                  .setSortable(true)
                  .setResizable(true);
        }
    }
    
    /**
     * Formats byte size to human-readable format.
     */
    private String formatByteSize(long bytes) {
        if (bytes < 1024) {
            return bytes + " bytes";
        } else if (bytes < 1024 * 1024) {
            return String.format("%.2f KB", bytes / 1024.0);
        } else if (bytes < 1024 * 1024 * 1024) {
            return String.format("%.2f MB", bytes / (1024.0 * 1024));
        } else {
            return String.format("%.2f GB", bytes / (1024.0 * 1024 * 1024));
        }
    }
    
    /**
     * Formats a database column name into a readable header.
     */
    private String formatColumnHeader(String dbColumnName) {
        if (dbColumnName == null || dbColumnName.isEmpty()) {
            return "Column";
        }
        
        return Arrays.stream(dbColumnName.replace("_", " ").split("\\s+"))
                .filter(word -> !word.isEmpty())
                .map(word -> word.substring(0, 1).toUpperCase() + word.substring(1).toLowerCase())
                .collect(Collectors.joining(" "));
    }
    
    /**
     * Configures a lazy loading data provider for the grid.
     */
    private void configureLazyDataProvider(Grid<Map<String, Object>> grid, 
                                           String baseQuery, 
                                           List<ColumnMetadata> columns) {
        // Create thread pool for concurrent fetching using virtual threads (JDK 21)
        ExecutorService executor = Executors.newVirtualThreadPerTaskExecutor();
        
        DataProvider<Map<String, Object>, Void> dataProvider = DataProvider.fromCallbacks(
            // First callback: Fetch items for the current page
            query -> {
                int offset = query.getOffset();
                int limit = query.getLimit();
                
                // Handle sorting
                List<QuerySortOrder> sortOrders = query.getSortOrders();
                String orderByClause = buildOrderByClause(sortOrders);
                
                // Build the final query with pagination and sorting
                String finalQuery = applyOracle12cPaginationAndSorting(baseQuery, orderByClause, limit, offset);
                
                // Fetch data using JDBC template
                List<Map<String, Object>> results = fetchData(finalQuery, columns);
                
                return results.stream();
            },
            // Second callback: Count total results for pagination
            query -> countTotalResults(baseQuery)
        );
        
        grid.setDataProvider(dataProvider);
    }
    
    /**
     * Builds an ORDER BY clause from Vaadin sort orders.
     */
    private String buildOrderByClause(List<QuerySortOrder> sortOrders) {
        if (sortOrders.isEmpty()) {
            return "";
        }
        
        return sortOrders.stream()
            .map(order -> order.getSorted() + " " + 
                 (order.getDirection() == SortDirection.ASCENDING ? "ASC" : "DESC"))
            .collect(Collectors.joining(", "));
    }
    
    /**
     * Applies Oracle-specific pagination and sorting to the base query.
     */
    private String applyOraclePaginationAndSorting(String baseQuery, 
                                                  String orderByClause, 
                                                  int limit, 
                                                  int offset) {
        StringBuilder queryBuilder = new StringBuilder();
        
        // Start with the base query
        String innerQuery = baseQuery;
        
        // Remove existing ORDER BY if present before adding new one
        int orderByIndex = baseQuery.toLowerCase().lastIndexOf("order by");
        if (orderByIndex != -1) {
            innerQuery = baseQuery.substring(0, orderByIndex);
        }
        
        // Add ORDER BY if provided
        if (!orderByClause.isEmpty()) {
            innerQuery += " ORDER BY " + orderByClause;
        }
        
        // For Oracle pre-12c we use ROWNUM with MINUS
        queryBuilder.append("SELECT * FROM (");
        queryBuilder.append(innerQuery);
        queryBuilder.append(") WHERE ROWNUM <= ").append(offset + limit);
        queryBuilder.append(" MINUS ");
        queryBuilder.append("SELECT * FROM (");
        queryBuilder.append(innerQuery);
        queryBuilder.append(") WHERE ROWNUM <= ").append(offset);
        
        return queryBuilder.toString();
    }
    
    /**
     * Alternative pagination method using Oracle 12c+ OFFSET/FETCH syntax.
     * Use this if your Oracle version supports it (12c and above).
     */
    private String applyOracle12cPaginationAndSorting(String baseQuery, 
                                                     String orderByClause, 
                                                     int limit, 
                                                     int offset) {
        StringBuilder queryBuilder = new StringBuilder();
        
        // Start with the base query
        queryBuilder.append(baseQuery);
        
        // Remove existing ORDER BY if present before adding new one
        int orderByIndex = baseQuery.toLowerCase().lastIndexOf("order by");
        if (orderByIndex != -1) {
            queryBuilder = new StringBuilder(baseQuery.substring(0, orderByIndex));
        }
        
        // Add ORDER BY if provided
        if (!orderByClause.isEmpty()) {
            queryBuilder.append(" ORDER BY ").append(orderByClause);
        } else {
            // Oracle requires an ORDER BY clause for OFFSET/FETCH
            queryBuilder.append(" ORDER BY 1");
        }
        
        // Add OFFSET/FETCH for pagination (Oracle 12c+ syntax)
        queryBuilder.append(" OFFSET ").append(offset).append(" ROWS");
        queryBuilder.append(" FETCH NEXT ").append(limit).append(" ROWS ONLY");
        
        return queryBuilder.toString();
    }
    
    /**
 * Fetches data using the final query with enhanced debugging for type mismatches.
 */
private List<Map<String, Object>> fetchData(String query, List<ColumnMetadata> columns) {
    System.out.println("Executing query: " + query);
    
    // Print expected column types from metadata for reference
    System.out.println("Expected column types from metadata:");
    for (ColumnMetadata col : columns) {
        System.out.println("  Column: " + col.name() + 
                           ", SQL Type: " + getSqlTypeName(col.sqlType()) + 
                           ", Java Type: " + col.javaType().getSimpleName());
    }
    
    return jdbcTemplate.query(query, (rs, rowNum) -> {
        // Only print detailed row info for the first row to avoid flooding logs
        boolean isFirstRow = (rowNum == 0);
        Map<String, Object> row = new HashMap<>();
        
        if (isFirstRow) {
            System.out.println("\nProcessing first row (#" + rowNum + "):");
        }
        
        // Get actual metadata from ResultSet for first row
        if (isFirstRow) {
            try {
                ResultSetMetaData rsMetaData = rs.getMetaData();
                System.out.println("Actual ResultSet metadata for first row:");
                for (int i = 1; i <= rsMetaData.getColumnCount(); i++) {
                    System.out.println("  Column: " + rsMetaData.getColumnName(i) + 
                                       ", SQL Type: " + getSqlTypeName(rsMetaData.getColumnType(i)) + 
                                       ", Type Name: " + rsMetaData.getColumnTypeName(i));
                }
            } catch (SQLException e) {
                System.err.println("Error fetching ResultSet metadata: " + e.getMessage());
            }
        }
        
        // Process each column
        for (ColumnMetadata col : columns) {
            try {
                if (isFirstRow) {
                    System.out.println("\nFetching column: " + col.name());
                    System.out.println("  Expected type: " + getSqlTypeName(col.sqlType()) + 
                                       " (" + col.javaType().getSimpleName() + ")");
                    
                    try {
                        // Try to identify actual type from the ResultSet
                        Object rawValue = rs.getObject(col.name());
                        if (rawValue != null) {
                            System.out.println("  Actual value class: " + rawValue.getClass().getName());
                        } else {
                            System.out.println("  Actual value is NULL");
                        }
                    } catch (SQLException e) {
                        System.out.println("  Could not get raw object: " + e.getMessage());
                    }
                }
                
                // Try to get typed value
                Object value = getTypedValue(rs, col);
                
                if (isFirstRow && value != null) {
                    System.out.println("  Converted value class: " + value.getClass().getName());
                    System.out.println("  Converted value: " + formatValueForLogging(value));
                }
                
                row.put(col.name(), value);
                
            } catch (SQLException e) {
                String message = "Error fetching column " + col.name() + ": " + e.getMessage();
                System.err.println(message);
                
                // Add more detailed error analysis
                if (e.getMessage().contains("inconsistent datatypes") || 
                    e.getMessage().contains("ORA-00932")) {
                    System.err.println("  Type mismatch detected! Oracle expected a different type than provided.");
                    System.err.println("  Try examining the actual database schema vs. the detected type.");
                    
                    // Try with getString as fallback with more diagnostics
                    try {
                        System.err.println("  Attempting fallback to getString...");
                        String strValue = rs.getString(col.name());
                        System.err.println("  getString succeeded: " + (strValue != null ? "value=" + strValue : "NULL"));
                        row.put(col.name(), strValue);
                    } catch (SQLException innerEx) {
                        System.err.println("  getString fallback also failed: " + innerEx.getMessage());
                        
                        // Last resort: try to identify the actual column type
                        try {
                            ResultSetMetaData rsmd = rs.getMetaData();
                            for (int i = 1; i <= rsmd.getColumnCount(); i++) {
                                if (col.name().equalsIgnoreCase(rsmd.getColumnName(i))) {
                                    System.err.println("  Actual column type from ResultSet metadata: " + 
                                                      rsmd.getColumnTypeName(i) + 
                                                      " (SQL Type ID: " + rsmd.getColumnType(i) + ")");
                                    break;
                                }
                            }
                        } catch (SQLException metaEx) {
                            System.err.println("  Could not retrieve column metadata: " + metaEx.getMessage());
                        }
                        
                        row.put(col.name(), null);
                    }
                } else {
                    // For other errors, just set to null
                    row.put(col.name(), null);
                }
            }
        }
        
        if (isFirstRow) {
            System.out.println("\nFinished processing first row");
        }
        
        return row;
    });
}

/**
 * Gets SQL type name from java.sql.Types constant
 */
private String getSqlTypeName(int sqlType) {
    return switch (sqlType) {
        case Types.CHAR -> "CHAR";
        case Types.VARCHAR -> "VARCHAR";
        case Types.LONGVARCHAR -> "LONGVARCHAR";
        case Types.NCHAR -> "NCHAR";
        case Types.NVARCHAR -> "NVARCHAR";
        case Types.LONGNVARCHAR -> "LONGNVARCHAR";
        case Types.NUMERIC -> "NUMERIC";
        case Types.DECIMAL -> "DECIMAL";
        case Types.BIT -> "BIT";
        case Types.BOOLEAN -> "BOOLEAN";
        case Types.TINYINT -> "TINYINT";
        case Types.SMALLINT -> "SMALLINT";
        case Types.INTEGER -> "INTEGER";
        case Types.BIGINT -> "BIGINT";
        case Types.REAL -> "REAL";
        case Types.FLOAT -> "FLOAT";
        case Types.DOUBLE -> "DOUBLE";
        case Types.BINARY -> "BINARY";
        case Types.VARBINARY -> "VARBINARY";
        case Types.LONGVARBINARY -> "LONGVARBINARY";
        case Types.DATE -> "DATE";
        case Types.TIME -> "TIME";
        case Types.TIMESTAMP -> "TIMESTAMP";
        case Types.CLOB -> "CLOB";
        case Types.BLOB -> "BLOB";
        case Types.ARRAY -> "ARRAY";
        case Types.STRUCT -> "STRUCT";
        case Types.REF -> "REF";
        case Types.DATALINK -> "DATALINK";
        case Types.ROWID -> "ROWID";
        case Types.NCLOB -> "NCLOB";
        case Types.SQLXML -> "SQLXML";
        case Types.REF_CURSOR -> "REF_CURSOR";
        case Types.TIME_WITH_TIMEZONE -> "TIME_WITH_TIMEZONE";
        case Types.TIMESTAMP_WITH_TIMEZONE -> "TIMESTAMP_WITH_TIMEZONE";
        default -> "UNKNOWN(" + sqlType + ")";
    };
}

/**
 * Formats a value for logging, handling special cases like byte arrays.
 */
private String formatValueForLogging(Object value) {
    if (value == null) {
        return "null";
    } else if (value instanceof byte[] bytes) {
        return "[Binary data, length: " + bytes.length + " bytes]";
    } else if (value.toString().length() > 100) {
        return value.toString().substring(0, 97) + "...";
    } else {
        return value.toString();
    }
}
    
    /**
     * Gets a properly typed value from the ResultSet based on column metadata.
     * Uses pattern matching (JDK 21 feature).
     */
    private Object getTypedValue(ResultSet rs, ColumnMetadata col) throws SQLException {
        if (rs.getObject(col.name()) == null) {
            return null;
        }
        
        // Handle different types with pattern matching
        return switch (col.sqlType()) {
            case Types.CHAR, Types.VARCHAR, Types.LONGVARCHAR, 
                 Types.NCHAR, Types.NVARCHAR, Types.LONGNVARCHAR, Types.CLOB -> rs.getString(col.name());
            case Types.NUMERIC, Types.DECIMAL -> rs.getBigDecimal(col.name());
            case Types.BIT, Types.BOOLEAN -> rs.getBoolean(col.name());
            case Types.TINYINT, Types.SMALLINT, Types.INTEGER -> rs.getInt(col.name());
            case Types.BIGINT -> rs.getLong(col.name());
            case Types.REAL, Types.FLOAT, Types.DOUBLE -> rs.getDouble(col.name());
            case Types.DATE -> rs.getDate(col.name()) != null ? 
                               rs.getDate(col.name()).toLocalDate() : null;
            case Types.TIMESTAMP -> rs.getTimestamp(col.name()) != null ? 
                                   rs.getTimestamp(col.name()).toLocalDateTime() : null;
            case Types.BLOB -> getBlobAsBytes(rs, col.name());
            case Types.BINARY, Types.VARBINARY, Types.LONGVARBINARY -> rs.getBytes(col.name());
            default -> {
                // For unknown or complex types, try getString first
                try {
                    yield rs.getString(col.name());
                } catch (SQLException e) {
                    // If getString fails, try getting as an Object
                    yield rs.getObject(col.name());
                }
            }
        };
    }
    
    /**
     * Converts a BLOB to a byte array safely.
     */
    private byte[] getBlobAsBytes(ResultSet rs, String columnName) throws SQLException {
        java.sql.Blob blob = rs.getBlob(columnName);
        if (blob == null) {
            return null;
        }
        
        try {
            // Get blob length
            long length = blob.length();
            
            // JDBC BLOBs are 1-indexed
            byte[] blobBytes = blob.getBytes(1, (int)length);
            
            // Free BLOB resource when done
            blob.free();
            
            return blobBytes;
        } catch (Exception e) {
            System.err.println("Error reading BLOB data: " + e.getMessage());
            return null;
        }
    }
    
    /**
     * Counts total results for pagination.
     */
    private int countTotalResults(String baseQuery) {
        // Create a count query from the base query
        String countQuery = buildCountQuery(baseQuery);
        Integer count = jdbcTemplate.queryForObject(countQuery, Integer.class);
        return count != null ? count : 0;
    }
    
    /**
     * Builds a count query from the base query.
     */
    private String buildCountQuery(String baseQuery) {
        // Remove ORDER BY and ROWNUM clauses if present
        String cleanQuery = removeOrderByAndRownum(baseQuery);
        return "SELECT COUNT(*) FROM (" + cleanQuery + ")";
    }
    
    /**
     * Removes ORDER BY and ROWNUM clauses from a query.
     */
    private String removeOrderByAndRownum(String query) {
        String lowerQuery = query.toLowerCase();
        
        // Remove ORDER BY clause
        int orderByIndex = lowerQuery.lastIndexOf("order by");
        if (orderByIndex != -1) {
            return query.substring(0, orderByIndex);
        }
        
        // If there's a WHERE ROWNUM condition, try to remove it
        int whereRownumIndex = lowerQuery.indexOf("where rownum");
        if (whereRownumIndex != -1) {
            return query.substring(0, whereRownumIndex);
        }
        
        return query;
    }
    
    /**
     * Provides direct access to retrieve a BLOB as byte array for external use.
     * Useful for downloading BLOB data.
     */
    public byte[] getBlobData(String tableName, String blobColumn, String keyColumn, Object keyValue) {
        String query = "SELECT " + blobColumn + " FROM " + tableName + " WHERE " + keyColumn + " = ?";
        
        try {
            return jdbcTemplate.queryForObject(query, (rs, rowNum) -> {
                try {
                    return getBlobAsBytes(rs, blobColumn);
                } catch (SQLException e) {
                    System.err.println("Error retrieving BLOB data: " + e.getMessage());
                    return null;
                }
            }, keyValue);
        } catch (Exception e) {
            System.err.println("Error executing BLOB query: " + e.getMessage());
            return null;
        }
    }
}
